/* Generated By:JavaCC: Do not edit this line. SyntaxChecker.java */
package org.catrobat.catroid.wrapper;

import org.catrobat.catroid.formulaeditor.Formula;
import org.catrobat.catroid.formulaeditor.FormulaElement;
import org.catrobat.catroid.formulaeditor.Functions;
import org.catrobat.catroid.formulaeditor.InternFormulaParser;
import org.catrobat.catroid.formulaeditor.InternToken;
import org.catrobat.catroid.formulaeditor.InternTokenType;
import org.catrobat.catroid.formulaeditor.Operators;
import org.catrobat.catroid.formulaeditor.Sensors;

import android.util.Log;

import java.util.LinkedList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

public class SyntaxChecker implements SyntaxCheckerConstants {

		private static class Pair<F, S> {
				private final F first;
				private final S second;

				public Pair(F first, S second) {
						this.first = first;
						this.second = second;
				}
		}

		private static final Map<String, Pair<InternTokenType, String>> tokenMap =
						new HashMap<String, Pair<InternTokenType, String>>();
		static {

				// Math
				tokenMap.put("sin", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.SIN.name()));
				tokenMap.put("cos", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.COS.name()));
				tokenMap.put("tan", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.TAN.name()));
				tokenMap.put("ln", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.LN.name()));
				tokenMap.put("log", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.LOG.name()));
				tokenMap.put("PI", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.PI.name()));
				tokenMap.put("pi", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.PI.name()));
				tokenMap.put("sqrt", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.SQRT.name()));
				tokenMap.put("random", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.RAND.name()));
				tokenMap.put("rand", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.RAND.name()));
				tokenMap.put("abs", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.ABS.name()));
				tokenMap.put("round", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.ROUND.name()));
				tokenMap.put("mod", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.MOD.name()));
				tokenMap.put("arcsin", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.ARCSIN.name()));
				tokenMap.put("arccos", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.ARCCOS.name()));
				tokenMap.put("arctan", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.ARCTAN.name()));
				tokenMap.put("exp", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.EXP.name()));
				tokenMap.put("max", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.MAX.name()));
				tokenMap.put("min", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.MIN.name()));

				tokenMap.put("length", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.LENGTH.name()));
				tokenMap.put("number_of_items", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.NUMBER_OF_ITEMS.name()));
				tokenMap.put("letter", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.LETTER.name()));
				tokenMap.put("join", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.JOIN.name()));
				tokenMap.put("element", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.LIST_ITEM.name()));
				tokenMap.put("contains", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.CONTAINS.name()));

				// Sensors
				tokenMap.put("acceleration_x", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.X_ACCELERATION.name()));
				tokenMap.put("acceleration_y", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.Y_ACCELERATION.name()));
				tokenMap.put("acceleration_z", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.Z_ACCELERATION.name()));
				tokenMap.put("compass_direction", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.COMPASS_DIRECTION.name()));
				tokenMap.put("inclination_x", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.X_INCLINATION.name()));
				tokenMap.put("inclination_y", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.Y_INCLINATION.name()));
				tokenMap.put("loudness", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.LOUDNESS.name()));

				// Object
				tokenMap.put("position_x", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_X.name()));
				tokenMap.put("position_y", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_Y.name()));
				tokenMap.put("transparency", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_TRANSPARENCY.name()));
				tokenMap.put("brightness", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_BRIGHTNESS.name()));
				tokenMap.put("size", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_SIZE.name()));
				tokenMap.put("direction", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_ROTATION.name()));
				tokenMap.put("layer", new Pair<InternTokenType, String>(InternTokenType.SENSOR, Sensors.OBJECT_LAYER.name()));

				// Logic
				tokenMap.put("=", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.EQUAL.name()));
				tokenMap.put("==", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.EQUAL.name()));
				tokenMap.put("!=", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.NOT_EQUAL.name()));
				tokenMap.put("<", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.SMALLER_THAN.name()));
				tokenMap.put("<=", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.SMALLER_OR_EQUAL.name()));
				tokenMap.put(">", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.GREATER_THAN.name()));
				tokenMap.put(">=", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.GREATER_OR_EQUAL.name()));
				tokenMap.put("AND", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_AND.name()));
				tokenMap.put("&", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_AND.name()));
				tokenMap.put("&&", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_AND.name()));
				tokenMap.put("OR", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_OR.name()));
				tokenMap.put("|", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_OR.name()));
				tokenMap.put("||", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_OR.name()));
				tokenMap.put("NOT", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_NOT.name()));
				tokenMap.put("!", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.LOGICAL_NOT.name()));
				tokenMap.put("TRUE", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.TRUE.name()));
				tokenMap.put("true", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.TRUE.name()));
				tokenMap.put("FALSE", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.FALSE.name()));
				tokenMap.put("false", new Pair<InternTokenType, String>(InternTokenType.FUNCTION_NAME, Functions.FALSE.name()));

				// Operators
				tokenMap.put("+", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.PLUS.name()));
				tokenMap.put("-", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.MINUS.name()));
				tokenMap.put("*", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.MULT.name()));
				tokenMap.put("/", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.DIVIDE.name()));
				tokenMap.put("^", new Pair<InternTokenType, String>(InternTokenType.OPERATOR, Operators.POW.name()));
		}

		public static void log(List<InternToken> tokens) {
				String s = "";
				for (InternToken t : tokens) {
						s += t.toString();
				}
//		Log.e("PARSER", "InternFormula: " + s);
		}

		public static void addNumber(List<InternToken> tokens, Token number) {
				tokens.add(new InternToken(InternTokenType.NUMBER, number.toString()));
		}

		public static void addToken(List<InternToken> tokens, Token token) {
				String tokenImage = token.toString();
				Pair<InternTokenType, String> x = tokenMap.get(tokenImage);
				if (x == null) {
						Log.e("PARSER", "Unknown token: " + tokenImage);
				}
				tokens.add(new InternToken(x.first, x.second));
		}

		public static void addVariable(List<InternToken> tokens, Token var) {
				tokens.add(new InternToken(InternTokenType.USER_VARIABLE, var.toString()));
		}

		public static void addString(List<InternToken> tokens, Token string) {
				tokens.add(new InternToken(InternTokenType.STRING, string.toString()));
		}

		public static void addList(List<InternToken> tokens, Token list) {
				tokens.add(new InternToken(InternTokenType.USER_LIST, list.toString()));
		}

		public static void addBracketOpen(List<InternToken> tokens) {
				tokens.add(new InternToken(InternTokenType.BRACKET_OPEN));
		}

		public static void addBracketClose(List<InternToken> tokens) {
				tokens.add(new InternToken(InternTokenType.BRACKET_CLOSE));
		}

		public static void addFunctionBracketOpen(List<InternToken> tokens) {
				tokens.add(new InternToken(InternTokenType.FUNCTION_PARAMETERS_BRACKET_OPEN));
		}

		public static void addFunctionBracketClose(List<InternToken> tokens) {
				tokens.add(new InternToken(InternTokenType.FUNCTION_PARAMETERS_BRACKET_CLOSE));
		}

		public static void addFunctionDelimiter(List<InternToken> tokens) {
				tokens.add(new InternToken(InternTokenType.FUNCTION_PARAMETER_DELIMITER));
		}

  final public Formula parse() throws ParseException {
		List<InternToken> tokens = new LinkedList<InternToken>();
	E(tokens);
	jj_consume_token(0);
				InternFormulaParser internParser = new InternFormulaParser(tokens);
				SyntaxChecker.log(tokens);
				{if (true) return new Formula(internParser.parseFormula());}
	throw new Error("Missing return statement in function");
  }

  final public void E(List<InternToken> tokens) throws ParseException {
		Token t;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case NUM:
	  t = jj_consume_token(NUM);
					SyntaxChecker.addNumber(tokens, t);
	  R(tokens);
	  break;
	case SENSOR:
	  t = jj_consume_token(SENSOR);
					   SyntaxChecker.addToken(tokens, t);
	  R(tokens);
	  break;
	case CONST:
	  t = jj_consume_token(CONST);
					  SyntaxChecker.addToken(tokens, t);
	  R(tokens);
	  break;
	case 11:
	  jj_consume_token(11);
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case NUM:
		t = jj_consume_token(NUM);
		break;
	  case STRING:
		t = jj_consume_token(STRING);
		break;
	  default:
		jj_la1[0] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
									 SyntaxChecker.addVariable(tokens, t);
	  jj_consume_token(12);
	  R(tokens);
	  break;
	case 13:
	  jj_consume_token(13);
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case NUM:
		t = jj_consume_token(NUM);
		break;
	  case STRING:
		t = jj_consume_token(STRING);
		break;
	  default:
		jj_la1[1] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
									 SyntaxChecker.addString(tokens, t);
	  jj_consume_token(13);
	  R(tokens);
	  break;
	case 14:
	  jj_consume_token(14);
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case NUM:
		t = jj_consume_token(NUM);
		break;
	  case STRING:
		t = jj_consume_token(STRING);
		break;
	  default:
		jj_la1[2] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
									 SyntaxChecker.addList(tokens, t);
	  jj_consume_token(15);
	  R(tokens);
	  break;
	case OP:
	  t = jj_consume_token(OP);
				   SyntaxChecker.addToken(tokens, t);
	  E(tokens);
	  R(tokens);
	  break;
	case FU:
	  t = jj_consume_token(FU);
				   SyntaxChecker.addToken(tokens, t);
	  jj_consume_token(16);
			  SyntaxChecker.addFunctionBracketOpen(tokens);
	  E(tokens);
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case 17:
		jj_consume_token(17);
					  SyntaxChecker.addFunctionDelimiter(tokens);
		E(tokens);
		break;
	  default:
		jj_la1[3] = jj_gen;
		;
	  }
	  jj_consume_token(18);
			  SyntaxChecker.addFunctionBracketClose(tokens);
	  R(tokens);
	  break;
	case 16:
	  jj_consume_token(16);
			  SyntaxChecker.addBracketOpen(tokens);
	  E(tokens);
	  jj_consume_token(18);
			  SyntaxChecker.addBracketClose(tokens);
	  R(tokens);
	  break;
	default:
	  jj_la1[4] = jj_gen;
	  jj_consume_token(-1);
	  throw new ParseException();
	}
  }

  final public void R(List<InternToken> tokens) throws ParseException {
		Token t;
	switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	case OP:
	  t = jj_consume_token(OP);
				   SyntaxChecker.addToken(tokens, t);
	  E(tokens);
	  break;
	default:
	  jj_la1[5] = jj_gen;

	}
  }

  /** Generated Token Manager. */
  public SyntaxCheckerTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[6];
  static private int[] jj_la1_0;
  static {
	  jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
	  jj_la1_0 = new int[] {0x420,0x420,0x420,0x20000,0x16be0,0x40,};
   }

  /** Constructor with InputStream. */
  public SyntaxChecker(java.io.InputStream stream) {
	 this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SyntaxChecker(java.io.InputStream stream, String encoding) {
	try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	token_source = new SyntaxCheckerTokenManager(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	 ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	token_source.ReInit(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SyntaxChecker(java.io.Reader stream) {
	jj_input_stream = new SimpleCharStream(stream, 1, 1);
	token_source = new SyntaxCheckerTokenManager(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	jj_input_stream.ReInit(stream, 1, 1);
	token_source.ReInit(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SyntaxChecker(SyntaxCheckerTokenManager tm) {
	token_source = tm;
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SyntaxCheckerTokenManager tm) {
	token_source = tm;
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 6; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	Token oldToken;
	if ((oldToken = token).next != null) token = token.next;
	else token = token.next = token_source.getNextToken();
	jj_ntk = -1;
	if (token.kind == kind) {
	  jj_gen++;
	  return token;
	}
	token = oldToken;
	jj_kind = kind;
	throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	if (token.next != null) token = token.next;
	else token = token.next = token_source.getNextToken();
	jj_ntk = -1;
	jj_gen++;
	return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	Token t = token;
	for (int i = 0; i < index; i++) {
	  if (t.next != null) t = t.next;
	  else t = t.next = token_source.getNextToken();
	}
	return t;
  }

  private int jj_ntk() {
	if ((jj_nt=token.next) == null)
	  return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	else
	  return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	jj_expentries.clear();
	boolean[] la1tokens = new boolean[19];
	if (jj_kind >= 0) {
	  la1tokens[jj_kind] = true;
	  jj_kind = -1;
	}
	for (int i = 0; i < 6; i++) {
	  if (jj_la1[i] == jj_gen) {
		for (int j = 0; j < 32; j++) {
		  if ((jj_la1_0[i] & (1<<j)) != 0) {
			la1tokens[j] = true;
		  }
		}
	  }
	}
	for (int i = 0; i < 19; i++) {
	  if (la1tokens[i]) {
		jj_expentry = new int[1];
		jj_expentry[0] = i;
		jj_expentries.add(jj_expentry);
	  }
	}
	int[][] exptokseq = new int[jj_expentries.size()][];
	for (int i = 0; i < jj_expentries.size(); i++) {
	  exptokseq[i] = jj_expentries.get(i);
	}
	return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
